module type S = sig
  (** The API that an RPC implementation library exports to the code generated by
      the capnp-ocaml schema compiler. *)

  module Payload : sig
    (** A read-only payload, used for both the function arguments as received
        by a service, or for the response message as received by the client.
        It contains a Cap'n'Proto struct and a set of references (corresponding to
        the CapDescriptor table). *)
    type 'a t

    (** An index into the CapDescriptor table, which will contain a ['b]. *)
    type 'b index = private Uint32.t
  end

  module Service : sig
    (** The type of a method provided by the server application code.
        This is used in the generated code for the service class type. *)
    type ('a, 'b) method_t
  end

  module StructRef : sig
    (** A reference to a struct, which may not have arrived yet. *)
    type 'a t
  end

  module Capability : sig
    (** A reference to an interface, which may be remote. *)
    type 'a t

    (** A method on some instance, as seen by the client application code.
        This is typically an [('a t, interface_id, method_id)] tuple.
        Used in the generated client classes. *)
    type ('a, 'b) method_t
  end

  module Untyped : sig
    (** This module is only for use by the code generated by the capnp-ocaml
        schema compiler. The generated code provides type-safe wrappers for
        everything here. *)

    (** An 8-byte slice containing a untyped Cap'n'Proto read-only pointer. *)
    type pointer_r

    (** [content_of_payload t] is the pointer to the payload's content struct.
        The compiler uses this to implement the [of_payload] methods in the
        generated files. *)
    val content_of_payload : 'a Payload.t -> pointer_r

    (** An untyped method. This will typically be something like
        ['a Payload.t -> 'b StructRef.t * 'b Lwt.t]. i.e. the result of
        calling an interface's method is a reference to the future result,
        which can be used for pipelining further requests, and a local
        promise for the message content of the result. *)
    type abstract_method_t

    (** Cast a method to [abstract_method_t]. Typically this will be the identity function.
        This is used in the generated code to ensure that all methods have the
        same type for the dispatch function. *)
    val abstract_method : ('a, 'b) Service.method_t -> abstract_method_t

    (** [bind_method t ~interface_id ~method_id] represents a reference to
        the [(interface_id, method_id)] method of [t]. Used to implement the
        methods in the generated client classes. *)
    val bind_method : _ Capability.t -> interface_id:Uint64.t -> method_id:int ->
      ('a, 'b) Capability.method_t

    (** [struct_field t i] is a reference to the struct found at pointer index [i]
        within the struct [t]. Used to implement the "_pipelined" accessors. *)
    val struct_field : 'a StructRef.t -> int -> 'b StructRef.t

    (** [capability_field t i] is a reference to the capability found at pointer index [i]
        within the struct [t]. Used to implement the "_pipelined" accessors. *)
    val capability_field : 'a StructRef.t -> int -> 'b Capability.t

    (** [local dispatch] is a capability reference to a local service implemented by [dispatch].
        Used in the generated dispatch functions. *)
    val local :
      (interface_id:Uint64.t -> method_id:int -> abstract_method_t) ->
      'a Capability.t

    (** Used in the generated code to record the type of a CapDescriptor index. *)
    val cap_index : Uint32.t option -> 'a Payload.index option

    (** Used to handle calls when the interface ID isn't known. *)
    val unknown_interface : interface_id:Uint64.t -> abstract_method_t

    (** Used to handle calls when the method ID isn't known. *)
    val unknown_method : interface_id:Uint64.t -> method_id:int -> abstract_method_t
  end
end

module None (M : MessageSig.S) = struct
  (** A dummy RPC provider, for when the RPC features (interfaces) aren't needed. *)

  type untyped_struct = [`No_RPC_struct]
  type untyped_cap = [`No_RPC_cap]
  type untyped_payload = [`No_RPC_payload]

  module StructRef = struct
    type 'a t = untyped_struct
  end

  module Capability = struct
    type 'a t = untyped_cap
    type ('a, 'b) method_t = Uint64.t * int
  end

  module Payload = struct
    type 'a t = untyped_payload
    type 'a index = Uint32.t
  end

  module Untyped = struct
    type pointer_r = Message.ro M.Slice.t option
    type abstract_method_t = untyped_payload -> untyped_struct

    let bind_method `No_RPC_cap ~interface_id ~method_id = (interface_id, method_id)
    let content_of_payload `No_RPC_payload = None

    let abstract_method x = x

    let struct_field `No_RPC_struct _ = `No_RPC_struct
    let capability_field `No_RPC_struct _ = `No_RPC_cap
    let local _ = `No_RPC_cap
    let cap_index x = x
    let unknown_interface ~interface_id:_ _req = failwith "Unknown interface"
    let unknown_method ~interface_id:_ ~method_id:_ _req = failwith "Unknown method"
  end

  module Service = struct
    type ('a, 'b) method_t = Untyped.abstract_method_t
  end
end

module Registry : sig
  (** Handy central registry of all known interfaces, for logging. *)

  (** Used in the generated code to register the interfaces. *)
  val register : interface_id:Uint64.t -> name:string -> (int -> string option) -> unit

  (** [pp_method] is a formatter for [(interface_id, method_id)] pairs.
      It prints out qualified names, suitable for logging
      (e.g. "Foo.bar") *)
  val pp_method : Format.formatter -> Uint64.t * int -> unit
end = struct
  type interface = {
    name : string;
    method_lookup : int -> string option;
  }

  let interfaces = Hashtbl.create 7

  let register ~interface_id ~name method_lookup =
    Hashtbl.add interfaces interface_id {name; method_lookup}

  let pp_method f (interface_id, method_id) =
    match Hashtbl.find interfaces interface_id with
    | exception Not_found ->
      Format.fprintf f "<interface %a>.<method-%d>"
        Uint64.printer interface_id
        method_id
    | interface ->
      match interface.method_lookup method_id with
      | Some method_name ->
        Format.fprintf f "%s.%s" interface.name method_name
      | None ->
        Format.fprintf f "%s.<method-%d>" interface.name method_id
end
